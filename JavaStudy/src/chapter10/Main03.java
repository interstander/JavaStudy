package chapter10;

public class Main03 {

	public static void main(String[] args) {
		A1 a = new A1();//일반적인 인스턴스 생성
        a.a1();
        
        A a1 = new A1();//참조타입을 인터페이스로 선언가능(인스턴스는 인터페이스를 구현한 클래스)
        a1.a1();//인터페이스는 기능의 존재를 알고 있으므로 구현 인스턴스 내부의 메소드 실행 가능
        
        C1 c1 = new C1(); //다중 구현 클래스 타입, 인스턴스
        c1.a1();  //다중 구현 클래스이므로 구현된 모든 메소드의 존재를 알고 있음=> 실행 가능
        c1.b1();
        
        A ca = new C1();//다중 구현 클래스로 만든 인스턴스=> 참조타입은 하나의 인터페이스
        ca.a1();  //인터페이스가 알고 있는 메소드는 실행가능
//      ca.b1();  //인터페이스가 모르는 메소드는 실행 불가능 => 인스턴스에는 존재
        
        B cb = new C1();//다중 구현 클래스로 만든 인스턴스=> 참조타입은 하나의 인터페이스
//      cb.a1();  //인터페이스가 모르는 메소드는 실행 불가능 => 인스턴스에는 존재
        cb.b1();  //인터페이스가 알고 있는 메소드는 실행가능
        
//--------------------------------------------------
        
        A da = new D1();//상속한 부모인터페이스를 참조 타입으로 상속받은 자식 인터페이스를 구현 한 인스턴스
        da.a1();  //부모인터페이스가 알고 있는 메소드 실행 가능
//      da.b1();  //인터페이스가 모르는 메소드는 실행 불가능 => 인스턴스에는 존재
//      da.d1();  //인터페이스가 모르는 메소드는 실행 불가능 => 인스턴스에는 존재
        
        B db = new D1();//상속한 부모인터페이스를 참조 타입으로 상속받은 자식 인터페이스를 구현 한 인스턴스
//      db.a1();//인터페이스가 모르는 메소드는 실행 불가능 => 인스턴스에는 존재
        db.b1();//부모인터페이스가 알고 있는 메소드 실행 가능
//      db.d1();//인터페이스가 모르는 메소드는 실행 불가능 => 인스턴스에는 존재
        
        D dd = new D1();//인터페이스를 구현한 인스턴스와 인터페이스 참조 타입
        dd.a1();  //인터페이스를 직접 구현했으므로 모든 메소드를 인터페이스가 알고 있음
        dd.b1();  //부모인터페이스의 추상메소드도 상속을 받았으므로 자식 인터페이스가알고 있음
        dd.d1();
        
        methodA(new D1());//부모 인터페이스로 구현한 인스턴스를 인자로 전달 가능
        methodB(new D1());//부모 인터페이스로 구현한 인스턴스를 인자로 전달 가능
        methodC(new D1());//인터페이스로 구현한 인스턴스를 인자로 전달 가능
        
//---------------------------------------------------
        D d1 = new D1();
        d1.a1(); d1.b1(); d1.d1();
        
        A a5 = d1;//자식 인터페이스로 만든 인스턴스이므로 부모 참조타입 변수에 할당 가능
        a5.a1(); //a5.b1(); a5.d1();//타입이 모르는 메소드는 실행 불가(인스턴스에는 존재)
        
        B b5 = (B)a5;//A인터페이스과 B인터페이스는 전혀 다르지만 인스턴스가 양쪽 모두를 구현하므로 강제 형변환 가능
        b5.b1(); //b5.a1() b5.d1();//타입이 모르는 메소드는 실행 불가(인스턴스에는 존재)
        
        B b4 = null;
        if(a5 instanceof B) {// a5 내부 객체는 타입B로 사용이 가능한가?
            b4 = (B)a5;     //a5 내부에 존재하는 인스턴스는 타입 B로 선언된 변수에 할당 가능
                          //(다만 사용 가능한 메소드 제한: B인터페이스가 알고 있는 메소드로 한정)
        }
        
        if (b4 == null) {//강제 형변환이 실패하면 b4에는 초기화가 안됨
            System.out.println("b4는 빈 객체");
        }else {
            b4.b1();//강제 형변환이 성공하면 b4에는 a5에 담겼던 인스턴스가 할당되어있음
        }

	}
	
//---------------------------------------------------	
	private static void methodA(A a) {
		a.a1();  //a.b1(); a.d1();//부모 인터페이스는 자신이 알고 있는 메소드만 실행 가능 
	}
	
	private static void methodB(B b) {
		 b.b1(); //b.a1(); b.d1();  //부모 인터페이스는 자신이 알고 있는 메소드만 실행 가능
	}
	
	private static void methodC(D d) {
		 d.a1(); d.b1(); d.d1();   //자식인터페이스는 모든 메소드를 알고 있다
	}

	

	
}
